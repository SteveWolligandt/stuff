#include <iostream>
#include <memory>
#include <vector>
//╔════════════════════════════════════════════════════════════════════════════╗
template <typename Derived>
struct crtp {
  //┌──────────────────────────────────────────────────────────────────────────┐
  //│ typedefs                                                                 │
  //├──────────────────────────────────────────────────────────────────────────┤
  
  using this_t = crtp<Derived>;
  using derived_t = Derived;

  //├──────────────────────────────────────────────────────────────────────────┤
  //│ methods                                                                  │
  //├──────────────────────────────────────────────────────────────────────────┤
  //├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
  /// returns casted as_derived data
  constexpr auto as_derived() -> decltype(auto) {
    return static_cast<Derived &>(*this);
  }
  //├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
  /// returns casted as_derived data
  constexpr auto as_derived() const -> decltype(auto) {
    return static_cast<Derived const &>(*this);
  }
}; // crtp
//╚════════════════════════════════════════════════════════════════════════════╝
//╔════════════════════════════════════════════════════════════════════════════╗
template <typename Real>
struct base {
  //┌──────────────────────────────────────────────────────────────────────────┐
  //│ typedefs                                                                 │
  //├──────────────────────────────────────────────────────────────────────────┤
  using real_t = Real;
  using this_t = base<Real>;
  //├──────────────────────────────────────────────────────────────────────────┤
  //│ ctors                                                                    │
  //└──────────────────────────────────────────────────────────────────────────┤
  constexpr base() = default;
  constexpr base(base const &) = default;
  constexpr base(base &&) noexcept = default;
  //├──────────────────────────────────────────────────────────────────────────┤
  //│ assignment operators                                                     │
  //├──────────────────────────────────────────────────────────────────────────┤
  constexpr auto operator=(base const &) -> base & = default;
  constexpr auto operator=(base &&) noexcept -> base & = default;
  //├──────────────────────────────────────────────────────────────────────────┤
  //│ dtor                                                                     │
  //├──────────────────────────────────────────────────────────────────────────┤
  virtual ~base() = default;

  //├──────────────────────────────────────────────────────────────────────────┤
  //│ methods                                                                  │
  //├──────────────────────────────────────────────────────────────────────────┤
  //├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
  virtual auto work() const -> Real = 0;
}; // base
//╚════════════════════════════════════════════════════════════════════════════╝
//╔════════════════════════════════════════════════════════════════════════════╗
template <typename Real, typename Derived>
struct parent : base<Real>, crtp<Derived> {
  //┌──────────────────────────────────────────────────────────────────────────┐
  //│ typedefs                                                                 │
  //├──────────────────────────────────────────────────────────────────────────┤
  using parent_base_t = base<Real>;
  using parent_crtp_t = crtp<Derived>;
  using this_t = parent<Real, Derived>;
  //├──────────────────────────────────────────────────────────────────────────┤
  //│ inherited methods                                                        │
  //├──────────────────────────────────────────────────────────────────────────┤
  using parent_crtp_t::as_derived;
  //├──────────────────────────────────────────────────────────────────────────┤
  //│ ctors                                                                    │
  //├──────────────────────────────────────────────────────────────────────────┤
  constexpr parent() = default;
  constexpr parent(parent const &) = default;
  constexpr parent(parent &&) noexcept = default;
  //├──────────────────────────────────────────────────────────────────────────┤
  //│ assignment operators                                                     │
  //├──────────────────────────────────────────────────────────────────────────┤
  constexpr auto operator=(parent const &) -> parent & = default;
  constexpr auto operator=(parent &&) noexcept -> parent & = default;
  //├──────────────────────────────────────────────────────────────────────────┤
  //│ dtor                                                                     │
  //├──────────────────────────────────────────────────────────────────────────┤
  ~parent() override = default;
  //├──────────────────────────────────────────────────────────────────────────┤
  //│ methods                                                                  │
  //├──────────────────────────────────────────────────────────────────────────┤
  auto work() const -> Real override { return as_derived().work(); }
};
//╚════════════════════════════════════════════════════════════════════════════╝
//╔════════════════════════════════════════════════════════════════════════════╗
template <typename Real>
struct impl0 : parent<Real, impl0<Real>> {
  //┌──────────────────────────────────────────────────────────────────────────┤
  //│ typedefs                                                                 │
  //├──────────────────────────────────────────────────────────────────────────┤
  using this_t = impl0<Real>;
  using parent_t = parent<Real, this_t>;
  //├──────────────────────────────────────────────────────────────────────────┤
  //│ methods                                                                  │
  //├──────────────────────────────────────────────────────────────────────────┤
  constexpr auto work() const -> Real final { return 0; }
};
//╚════════════════════════════════════════════════════════════════════════════╝
//╔════════════════════════════════════════════════════════════════════════════╗
template <typename Real>
struct impl1 : parent<Real, impl1<Real>> {
  //┌──────────────────────────────────────────────────────────────────────────┐
  //│ typedefs                                                                 │
  //├──────────────────────────────────────────────────────────────────────────┤
  using this_t = impl0<Real>;
  using parent_t = parent<Real, this_t>;
  //├──────────────────────────────────────────────────────────────────────────┤
  //│ methods                                                                  │
  //├──────────────────────────────────────────────────────────────────────────┤
  constexpr auto work() const -> Real final { return 1; }
};
//╚════════════════════════════════════════════════════════════════════════════╝
//╔════════════════════════════════════════════════════════════════════════════╗
template <typename Real>
struct impl2 : parent<Real, impl1<Real>> {
  //┌──────────────────────────────────────────────────────────────────────────┐
  //│ typedefs                                                                 │
  //├──────────────────────────────────────────────────────────────────────────┤
  using this_t = impl0<Real>;
  using parent_t = parent<Real, this_t>;
  //├──────────────────────────────────────────────────────────────────────────┤
  //│ ctors                                                                    │
  //├──────────────────────────────────────────────────────────────────────────┤
  constexpr impl2(Real v) : m_v{v} {}
  constexpr impl2(impl2 const &) = default;
  constexpr impl2(impl2 &&) noexcept = default;
  //├──────────────────────────────────────────────────────────────────────────┤
  //│ assignment operators                                                     │
  //├──────────────────────────────────────────────────────────────────────────┤
  constexpr auto operator=(impl2 const &) -> impl2 & = default;
  constexpr auto operator=(impl2 &&) noexcept -> impl2 & = default;
  //├──────────────────────────────────────────────────────────────────────────┤
  //│ dtor                                                                     │
  //├──────────────────────────────────────────────────────────────────────────┤
  ~impl2() override = default;
  //├──────────────────────────────────────────────────────────────────────────┤
  //│ members                                                                  │
  //├──────────────────────────────────────────────────────────────────────────┤
  Real m_v;
  //├──────────────────────────────────────────────────────────────────────────┤
  //│ methods                                                                  │
  //├──────────────────────────────────────────────────────────────────────────┤
  constexpr auto work() const -> Real final { return m_v; }
};
//╚════════════════════════════════════════════════════════════════════════════╝
//╞════════════════════════════════════════════════════════════════════════════╡
//│ free functions                                                             │
//╞════════════════════════════════════════════════════════════════════════════╡
template <typename Real, typename Derived>
constexpr auto work(parent<Real, Derived> const &i) {
  return i.work();
}
//├────────────────────────────────────────────────────────────────────────────┤
template <typename Real, typename Derived>
constexpr auto work(base<Real> const &i) {
  return i.work();
}
//├────────────────────────────────────────────────────────────────────────────┤
template <typename Real, typename Derived>
constexpr auto work(std::unique_ptr<base<Real>> const &i) {
  return i->work();
}
//╔════════════════════════════════════════════════════════════════════════════╗
//║ main                                                                       ║
//╚════════════════════════════════════════════════════════════════════════════╝
auto main() -> int {
  using std::make_unique;
  using baseptr_t = std::unique_ptr<base<double>>;
  using vector_t = std::vector<baseptr_t>;
  vector_t is;
  is.push_back(make_unique<impl0<double>>());
  is.push_back(make_unique<impl1<double>>());
  is.push_back(make_unique<impl2<double>>(5));
  is.push_back(make_unique<impl2<double>>(10));
  for (auto const &i : is) {
    std::cerr << i->work() << '\n';
  }
}
